import { OTP } from '@entities/otp.entity';
import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindOptionsWhere, MoreThanOrEqual, Repository } from 'typeorm';
import { UserService } from './user.service';
import { User } from '@entities/user.entity';

@Injectable()
export class OtpService {
    constructor(
        @InjectRepository(OTP)
        private otpRespository: Repository<OTP>,
        private userService: UserService
    ) { }

    /**
     * 
     * @param email The email addresss of the user
     * @returns A OTP entity
     * @description This method generates a new OTP for the user with the a particular email address
     */
    async create(email: string): Promise<OTP> {
        const user = await this.userService.findOne({ email });
        if (!user) {
            throw new HttpException('User not found', HttpStatus.NOT_MODIFIED);
        }

        // Generate a new password for the OTP
        let password
        do {
            password = this.generatePassword()
        } while (await this.isPasswordUsedOrRecent(password, user))

        // Create and save the OTP instance
        const otpInstance = this.otpRespository.create({ password, user })
        return this.otpRespository.save(otpInstance)
    }

    /**
     * 
     * @param password The OTP password
     * @param user The user the OTP is being generated for
     * @returns A boolean indicating if the password has been used, or generated by the same user in the last 24 hours (two birds with one stone)
     */
    private async isPasswordUsedOrRecent(password: string, user: User): Promise<boolean> {
        const otp = await this.otpRespository.findOne({
            where: [
                { used: true, password },
                { user, password, created: MoreThanOrEqual(new Date(Date.now() - 24 * 60 * 60 * 1000)) }
            ]
        });
        return !!otp;
    }

    /**
     * 
     * @returns A radomly generated 6 digit string of numbers
     * @description The only reason this work is because of how JavaScript uses the IEEE 754 standard for representing floating-point numbers
     * 1.99999 - 0.99999 - 0.9999999999999999, decimals in binary cannot be accurately represented 
     * So I am using this bug as a feature, this method will alway return a 6 digit string of numbers, and the first digit can be a 0 (1.99999 - 1 = 0,99999)
     */
    private generatePassword(): string {
        return (1.99999 - Math.random()).toFixed().replace(".", "").substring(0, 6)
    }

    /**
     * 
     * @param where the key value pairs to search for
     * @returns A OTP entity
     * @description This method finds an OTP that matches the given key value pairs given as parameters
     */
    async find(where: FindOptionsWhere<OTP>) {
        return this.otpRespository.findOne({ where })
    }

    /**
     * 
     * @param id The ID of the OTP
     * @param data The data of the OTP to update
     * @returns An OTP entity that has been updated
     * @description This method updates an OTP with a particular ID
     */
    async update(id: number, data: Partial<OTP>) {
        return await this.otpRespository.update(id, data)
    }
}
